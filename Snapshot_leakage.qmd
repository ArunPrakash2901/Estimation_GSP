---
title: "Snapshot_leakage"
format: html
---

```{r}
suppressPackageStartupMessages({
  library(readr); library(dplyr); library(tidyr)
  library(stringr); library(tsibble); library(lubridate); library(purrr)
})

# Paths
PATH_SNAPSHOTS <- "data/baseline/q_panel_snapshots.csv"
PATH_WITHINQ   <- "data/baseline/within_quarter_coverage.csv"
PATH_CUTS      <- "data/baseline/snapshot_cuts.csv"


# 1) Make sure we have a 'value' column (handles value_q)
coerce_value_col <- function(df) {
  cand <- intersect(names(df), c("value", "value_q", "value_transformed", "y", "val"))
  if (length(cand) == 0) stop("No value column found. Expected one of: value, value_q, value_transformed, y, val.")
  if (!"value" %in% names(df)) df <- dplyr::rename(df, value = !!cand[1])
  df
}

# 2) Normalize common id columns (adds 'label' as snapshot candidate)
coerce_common_cols <- function(df) {
  # freq
  if (!"freq" %in% names(df)) {
    alt <- intersect(names(df), c("frequency","freq_code"))
    if (length(alt)) df <- dplyr::rename(df, freq = !!alt[1])
  }
  # snapshot_id
  if (!"snapshot_id" %in% names(df)) {
    alt <- intersect(names(df), c("snapshot","snap_id","label"))
    if (length(alt)) df <- dplyr::rename(df, snapshot_id = !!alt[1])
  }
  # state
  if (!"state" %in% names(df)) {
    alt <- intersect(names(df), c("region","state_code"))
    if (length(alt)) df <- dplyr::rename(df, state = !!alt[1])
  }
  # series_id
  if (!"series_id" %in% names(df)) {
    alt <- intersect(names(df), c("series","id"))
    if (length(alt)) df <- dplyr::rename(df, series_id = !!alt[1])
  }
  df
}

# 3) Parse time columns; accept qtr_end (Date), q (string), period/date/month/quarter
add_time_cols <- function(df) {
  tcol <- intersect(names(df), c("qtr_end","q","period","date","time","month","quarter","obs_time","year_month","yearquarter"))
  if (length(tcol) == 0) stop("No time/period column found.")
  tcol <- tcol[1]
  x <- df[[tcol]]

  if (inherits(x, "yearquarter") || inherits(x, "yearmonth")) {
    ; # already parsed
  } else if (inherits(x, "Date")) {
    df$yearmonth   <- tsibble::yearmonth(x)
    df$yearquarter <- tsibble::yearquarter(x)
  } else if (is.character(x)) {
    ym_try <- suppressWarnings(lubridate::ymd(paste0(x, "-01")))
    if (all(is.na(ym_try))) {
      q_try <- suppressWarnings(tsibble::yearquarter(x))
      if (all(is.na(q_try))) {
        dt_try <- suppressWarnings(lubridate::ymd(x))
        if (!all(is.na(dt_try))) {
          df$yearmonth   <- tsibble::yearmonth(dt_try)
          df$yearquarter <- tsibble::yearquarter(dt_try)
        } else {
          stop("Could not parse period; supply Date/YearMonth/YearQuarter or 'YYYY-MM'/'YYYY Q#'.")
        }
      } else {
        df$yearquarter <- q_try
      }
    } else {
      df$yearmonth   <- tsibble::yearmonth(ym_try)
      df$yearquarter <- tsibble::yearquarter(ym_try)
    }
  } else {
    stop("Unsupported time/period column type.")
  }

  if (!"yearquarter" %in% names(df)) df$yearquarter <- tsibble::yearquarter(df[[tcol]])
  df
}

# 4) Yearquarter coercer
as_yq <- function(x) { if (inherits(x, "yearquarter")) x else tsibble::yearquarter(as.character(x)) }

# 5) Month index inside quarter (1/2/3)
m_in_q <- function(ym) { ((month(as.Date(ym)) - 1) %% 3) + 1 }

# 6) Stage name from snapshot_id
stage_from_id <- function(x) {
  x <- toupper(as.character(x))
  dplyr::case_when(
    stringr::str_detect(x, "T\\+?15|T15") ~ "T+15",
    stringr::str_detect(x, "T\\+?45|T45") ~ "T+45",
    stringr::str_detect(x, "T\\+?75|T75") ~ "T+75",
    TRUE ~ "Unknown"
  )
}


# Snapshots (panel across snapshots)
snap <- readr::read_csv(PATH_SNAPSHOTS, show_col_types = FALSE) |>
  coerce_common_cols() |>
  coerce_value_col() |>
  add_time_cols()

# Cuts (snapshot -> cutoff date & target quarter)
cuts_raw <- readr::read_csv(PATH_CUTS, show_col_types = FALSE)

.norm <- function(x) tolower(gsub("[^a-z0-9]", "", x))
find_first_col <- function(df, candidates) {
  nn <- .norm(names(df)); cc <- .norm(candidates)
  hit <- match(cc, nn); hit <- hit[!is.na(hit)]
  if (length(hit) == 0) return(NA_character_)
  names(df)[hit[1]]
}

snap_candidates   <- c("snapshot_id","snapshot","snap_id","snap","label","id","snapshotid")
target_candidates <- c("target_quarter","target_q","target_qtr","target_yq","target","yq","quarter","q")
cut_candidates    <- c("cutoff_date","cutoff","cutoff_dt","cut_date","cut","cut_dt","as_of","snapshot_date","date")

snap_col   <- find_first_col(cuts_raw, snap_candidates)
target_col <- find_first_col(cuts_raw, target_candidates)
cut_col    <- find_first_col(cuts_raw, cut_candidates)

if (is.na(snap_col))   stop("snapshot_cuts.csv: could not find snapshot id column; saw: ", paste(names(cuts_raw), collapse=", "))
if (is.na(target_col)) stop("snapshot_cuts.csv: could not find target quarter column; saw: ", paste(names(cuts_raw), collapse=", "))
if (is.na(cut_col))    stop("snapshot_cuts.csv: could not find cutoff date column; saw: ", paste(names(cuts_raw), collapse=", "))

cuts <- cuts_raw
names(cuts)[names(cuts) == snap_col]   <- "snapshot_id"
names(cuts)[names(cuts) == target_col] <- "target_quarter"
names(cuts)[names(cuts) == cut_col]    <- "cutoff_date"

cuts <- cuts |>
  mutate(
    snapshot_id    = as.character(snapshot_id),
    target_quarter = as_yq(target_quarter),
    cutoff_date    = as.Date(cutoff_date)
  )

cat("cuts normalized ->", paste(names(cuts), collapse=", "), "\n")
print(utils::head(cuts, 3))

# Within-quarter coverage
within_q <- readr::read_csv(PATH_WITHINQ, show_col_types = FALSE) |>
  coerce_common_cols()

# Coverage columns: allow months_seen OR month_in_quarter + is_observed
if (!"month_in_quarter" %in% names(within_q)) {
  alt <- intersect(names(within_q), c("m_in_q","month_idx","month_no","m_q","months_seen"))
  if (length(alt)) within_q <- dplyr::rename(within_q, month_in_quarter = !!alt[1])
}
if (!"is_observed" %in% names(within_q)) {
  if ("months_seen" %in% names(within_q)) {
    within_q <- within_q |>
      mutate(is_observed = as.integer(month_in_quarter) > 0)
  } else {
    alt <- intersect(names(within_q), c("observed","is_released","available"))
    if (length(alt)) within_q <- dplyr::rename(within_q, is_observed = !!alt[1])
  }
}


# Within-quarter coverage
within_q <- readr::read_csv(PATH_WITHINQ, show_col_types = FALSE) |>
  coerce_common_cols()

if ("month_in_quarter" %in% names(within_q)) {
  # Case A: already one row per month (1/2/3). Coerce/create is_observed.
  if (!"is_observed" %in% names(within_q)) {
    # try common alternatives; else default to TRUE (present) if a truthy string/number
    if ("observed" %in% names(within_q)) {
      within_q <- within_q |>
        mutate(is_observed = if (is.logical(observed)) observed
                              else tolower(as.character(observed)) %in% c("1","true","t","yes","y"))
    } else if ("is_released" %in% names(within_q)) {
      within_q <- within_q |>
        mutate(is_observed = if (is.logical(is_released)) is_released
                              else tolower(as.character(is_released)) %in% c("1","true","t","yes","y"))
    } else if ("available" %in% names(within_q)) {
      within_q <- within_q |>
        mutate(is_observed = if (is.logical(available)) available
                              else tolower(as.character(available)) %in% c("1","true","t","yes","y"))
    } else {
      stop("Found month_in_quarter but no is_observed/observed/is_released/available column.")
    }
  } else {
    # normalize is_observed to logical
    within_q <- within_q |>
      mutate(is_observed = if (is.logical(is_observed)) is_observed
                            else tolower(as.character(is_observed)) %in% c("1","true","t","yes","y"))
  }

  within_q <- within_q |>
    mutate(month_in_quarter = as.integer(month_in_quarter),
           is_observed = coalesce(is_observed, FALSE))

} else if ("months_seen" %in% names(within_q)) {
  # Case B: expand from a count (0..3) to rows for m=1,2,3
  within_q <- within_q |>
    select(snapshot_id, state, series_id, months_seen) |>
    distinct() |>
    mutate(months_seen = pmax(0L, pmin(3L, as.integer(months_seen)))) |>
    tidyr::crossing(month_in_quarter = 1:3) |>
    mutate(is_observed = month_in_quarter <= months_seen)

} else {
  stop("within_quarter_coverage must include either month_in_quarter (+ flag) or months_seen.")
}

# check: months_seen should be 0-3 if present
if ("months_seen" %in% names(within_q)) {
  rng <- range(within_q$months_seen, na.rm = TRUE)
  if (any(is.finite(rng)) && (rng[1] < 0 || rng[2] > 3)) {
    warning("months_seen has values outside 0..3; clipped to that range in expansion.")
  }
}

#  Tag target series (state GSP)
# explicit ABS IDs 
TARGET_SERIES <- c(
  "A2303111F","A2303139J","A2303187A",
  "A2302956R","A2302984X","A2303012X",
  "A2303040J","A2303068K",
  "A2304418T","A2304404C"
)

tag_targets <- function(snap) {
  snap <- snap |> dplyr::mutate(series_id = as.character(series_id))

  # If your explicit list hits, use it; else try 'rule' column; else fall back to pattern
  if (length(TARGET_SERIES) > 0 && any(snap$series_id %in% TARGET_SERIES, na.rm = TRUE)) {
    snap <- snap |> dplyr::mutate(is_target = series_id %in% TARGET_SERIES)
  } else if ("rule" %in% names(snap) && any(!is.na(snap$rule))) {
    snap <- snap |> dplyr::mutate(is_target = stringr::str_detect(tolower(rule), "gsp|target"))
  } else {
    snap <- snap |> dplyr::mutate(
      is_target = stringr::str_detect(series_id, stringr::regex("GSP|Gross State Product|state gdp", ignore_case = TRUE))
    )
  }

  # quick sanity print
  cat("Tagged", sum(snap$is_target, na.rm = TRUE), "rows as target across",
      dplyr::n_distinct(snap$state), "states.\n")
  print(
    snap |> dplyr::filter(is_target) |>
      dplyr::count(state, series_id, sort = TRUE) |> utils::head(10)
  )
  snap
}

# Apply tagging
snap <- tag_targets(snap)


snap_y <- snap |> filter(is_target)

snap_y_q <- snap_y |>
  group_by(snapshot_id, state, series_id, yearquarter) |>
  summarise(any_nonNA = any(!is.na(value)), .groups = "drop") |>
  left_join(cuts |> select(snapshot_id, target_quarter), by = "snapshot_id") |>
  group_by(snapshot_id, state, series_id) |>
  summarise(
    max_published_qtr = {
      z <- yearquarter[any_nonNA]
      if (length(z) > 0) max(z) else as_yq(NA_character_)
    },
    has_any         = any(any_nonNA),
    target_quarter  = unique(target_quarter),
    leak_in_targetq = any(any_nonNA & (yearquarter == target_quarter), na.rm = TRUE),
    leak_beyond     = any(any_nonNA & (yearquarter >  target_quarter), na.rm = TRUE),
    .groups = "drop"
  ) |>
  mutate(ok_no_leak = (!leak_in_targetq & !leak_beyond)) |>
  arrange(snapshot_id, state)

cat("\n TARGET LEAKAGE CHECK (y_history) \n")
print(snap_y_q |> select(snapshot_id, state, series_id,
                         max_published_qtr, target_quarter,
                         leak_in_targetq, leak_beyond, ok_no_leak))
if (all(snap_y_q$ok_no_leak, na.rm = TRUE)) {
  cat("PASS: No leakage detected for target y_history.\n")
} else {
  cat("FAIL: Leakage detected for target y_history. Inspect rows above.\n")
}


# Infer which series are monthly (no freq column needed)
# A series is treated as monthly if, in any snapshot & quarter, it has >= 2 distinct yearmonths.
freq_map <- snap |>
  dplyr::filter(!is.na(yearquarter)) |>
  dplyr::group_by(series_id, state, snapshot_id, yearquarter) |>
  dplyr::summarise(n_months_in_q = dplyr::n_distinct(yearmonth[!is.na(yearmonth)]), .groups = "drop") |>
  dplyr::group_by(series_id, state) |>
  dplyr::summarise(is_monthly_series = any(n_months_in_q >= 2, na.rm = TRUE), .groups = "drop")

snap <- snap |>
  dplyr::left_join(freq_map, by = c("series_id","state")) |>
  dplyr::mutate(is_monthly_series = dplyr::coalesce(is_monthly_series, FALSE))

# Keep monthly predictors and restrict to target quarter
snap_m <- snap |>
  dplyr::filter(!is_target, is_monthly_series) |>
  dplyr::left_join(cuts |> dplyr::select(snapshot_id, target_quarter), by = "snapshot_id") |>
  dplyr::filter(!is.na(yearquarter) & yearquarter == target_quarter) |>
  dplyr::filter(!is.na(yearmonth)) |>
  dplyr::mutate(month_in_quarter = m_in_q(yearmonth)) |>
  dplyr::select(snapshot_id, state, series_id, month_in_quarter, value)

# check: monthly series should have month_in_quarter in {1,2,3}
print(snap_m |> dplyr::count(month_in_quarter, sort = TRUE))

pred_check <- snap_m |>
  left_join(within_q |> select(snapshot_id, state, series_id, month_in_quarter, is_observed),
            by = c("snapshot_id","state","series_id","month_in_quarter")) |>
  mutate(
    is_na_value = is.na(value),
    aligns_with_coverage = case_when(
      is_observed &  is_na_value ~ FALSE,  # should be present but NA
      !is_observed & !is_na_value ~ FALSE, # should be missing but present
      is_observed & !is_na_value ~ TRUE,
      !is_observed &  is_na_value ~ TRUE,
      TRUE ~ NA
    )
  )

cat("\n PREDICTOR NA ALIGNMENT vs coverage \n")
pred_summary <- pred_check |>
  group_by(snapshot_id) |>
  summarise(
    n_cells = n(),
    n_ok    = sum(aligns_with_coverage %in% TRUE, na.rm = TRUE),
    n_bad   = sum(aligns_with_coverage %in% FALSE, na.rm = TRUE),
    ok_pct  = round(100 * n_ok / pmax(1, n_cells), 1),
    .groups = "drop"
  ) |>
  arrange(snapshot_id)

print(pred_summary)
if (all(pred_summary$n_bad == 0)) {
  cat("PASS: Coverage alignment is clean (observed = non-NA, not-observed = NA).\n")
} else {
  cat("FAIL: Some cells violate coverage rules. See a few below.\n")
  print(pred_check |> filter(aligns_with_coverage %in% FALSE) |> head(20))
}


coverage_by_series <- pred_check |>
  mutate(stage = stage_from_id(snapshot_id)) |>
  group_by(snapshot_id, stage, state, series_id) |>
  summarise(months_present = sum(!is.na(value)), .groups = "drop")

cat("\nMonths present distribution by snapshot\n")
print(
  coverage_by_series |>
    group_by(snapshot_id, stage, months_present) |>
    summarise(n_series = n(), .groups = "drop") |>
    arrange(snapshot_id, months_present)
)
cat("Rule of thumb: T+15 ≈ 1 month; T+45 ≈ 2; T+75 ≈ 3.\n")

```






